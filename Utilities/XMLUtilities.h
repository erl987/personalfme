/*	PersonalFME - Gateway linking analog radio selcalls to internet communication services
Copyright(C) 2010-2023 Ralf Rettig (www.personalfme.de)

This program is free software: you can redistribute it and / or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.If not, see <http://www.gnu.org/licenses/>
*/
#pragma once
#include <string>
#include <fstream>
#include <sstream>
#include <boost/filesystem.hpp>
#include <Poco/Util/XMLConfiguration.h>
#include "FileUtils.h"
#include "XMLException.h"
#include "XMLValidator.h"

#if defined _WIN32 || defined __CYGWIN__
	#ifdef UTILITY_API
		// All functions in this file are exported
	#else
		// All functions in this file are imported
		// Windows
		#ifdef __GNUC__
			// GCC
			#define UTILITY_API __attribute__ ((dllimport))
		#else
			// Microsoft Visual Studio
			#define UTILITY_API __declspec(dllimport)
		#endif
	#endif
#else
	// Linux
	#if __GNUC__ >= 4
		#define UTILITY_API __attribute__ ((visibility ("default")))
	#else
		#define UTILITY_API
	#endif		
#endif


/*@{*/
/** \ingroup Utilities
*/
namespace Utilities {
	namespace XML {
		template<typename T> void WriteXML( const boost::filesystem::path& xmlFile, const T& data, const std::string& rootTag, const std::pair<std::string, boost::filesystem::path>& xmlSchemaLocation );
		template<typename T> void ReadXML( const boost::filesystem::path& xmlFile, T& data, const std::pair<std::string, boost::filesystem::path>& xmlSchemaLocation = std::pair<std::string, boost::filesystem::path>() );
		UTILITY_API std::string AddXMLHeader( const std::string& xmlString, const std::string& rootTag, const std::pair<std::string, boost::filesystem::path>& xmlSchemaLocation );
	}
}
/*@}*/


/** @brief		Writes an XML-serializable data structure to an XML-file
*	@param		xmlFile						XML-file to be written
*	@param		data						Data to be written to file. It must XML-serializable, i.e. be derived from Utilities::XML::CXMLSerializable.
*	@param		rootTag						Root tag of the XML-data structure
*	@param		xmlSchemaLocation			XML schema location (XML namespace, XSD file location) to be used in the XML-file
*	@return									None
*	@exception	Exception::xml_error		Thrown in case of XML-errors (which can only happen due to some invalid data that was tried to be incorporated into the XML-file)
*	@remarks								The XML-file is validated using its XML schema definition
*/
template<typename T>
void  Utilities::XML::WriteXML( const boost::filesystem::path& xmlFile, const T& data, const std::string& rootTag, const std::pair<std::string, boost::filesystem::path>& xmlSchemaLocation )
{
	using namespace std;
	using namespace Poco::Util;

	Utilities::XML::CXMLValidator xmlValidator;
	stringstream xmlStrStream;
	string xmlString;
	ofstream xmlFileStream( xmlFile.string() );

	// write the XML-file
	Poco::AutoPtr<XMLConfiguration> xmlFileWriter( new XMLConfiguration );
	xmlFileWriter->loadEmpty( rootTag );
	data.GenerateXML( xmlFileWriter );
	xmlFileWriter->save( xmlStrStream );
	xmlString = xmlStrStream.str();

	// add the XML-header (not generated by the Poco-library)
	xmlString = AddXMLHeader( xmlString, rootTag, xmlSchemaLocation );
	xmlFileStream << xmlString;
	xmlFileStream.close();

	// validate the XML-file with the Xerces-library using the XML-schema file
	xmlValidator.ValidateSchema( xmlFile ); // this will throw a Utilities::Exception::xml_error exception if the XML-file is invalid
}



/** @brief		Reads data from an XML-file into an XML-serializable data structure
*	@param		xmlFile						XML-file to be validated
*	@param		data						Data to be filled from the file. It must XML-serializable, i.e. be derived from Utilities::XML::CXMLSerializable.
*	@param		xmlSchemaLocation			External XML schema location (XML namespace, XSD file location) to be used instead of that possibly defined in the XML-file. Omit it, if that defined in the XML-file should be used.
*	@return									None
*	@exception	Exception::xml_error		Thrown in case of XML-parsing errors
*	@remarks								The XML-file is validated using the XML schema definition
*/
template<typename T>
void Utilities::XML::ReadXML( const boost::filesystem::path& xmlFile, T& data, const std::pair<std::string, boost::filesystem::path>& xmlSchemaLocation )
{
	using namespace Poco::Util;

	std::string exceptionMessage;
	Utilities::XML::CXMLValidator xmlValidator;

	// validate the XML-file with the Xerces-library using the XML-schema file
	try {
		xmlValidator.ValidateSchema( xmlFile, xmlSchemaLocation ); // this will throw a Utilities::Exception::xml_error exception if the XML-file is invalid

		// parse the valid XML-file using the Poco-library
		try {
			auto tempPathChanger = Utilities::File::TemporaryPathChange( xmlFile.parent_path() ); // will change back to the current directory when going out of scope
			Poco::AutoPtr<XMLConfiguration> xmlFileReader( new XMLConfiguration( xmlFile.filename().string() ) );
			data.SetFromXML( xmlFileReader );
		} catch ( Poco::Exception& e ) {
			throw Exception::xml_error( "error:\t" + e.message() );
		}
	} catch ( Exception::xml_error& e ) {
		// rethrow the exception adding the file information
		throw Exception::xml_error( "XML-parser error:\nfile:\t" + xmlFile.string() + "\n" + e.what() );
	}
}